{"ast":null,"code":"import { useRef, useCallback } from 'react';\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\nimport { addPointerEvent, usePointerEvent } from '../events/use-pointer-event.mjs';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { isDragActive } from './drag/utils/lock.mjs';\nimport { pipe } from '../utils/pipe.mjs';\nimport { addDomEvent, useDomEvent } from '../events/use-dom-event.mjs';\nimport { extractEventInfo } from '../events/event-info.mjs';\n\nfunction fireSyntheticPointerEvent(name, handler) {\n  if (!handler) return;\n  const syntheticPointerEvent = new PointerEvent(\"pointer\" + name);\n  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));\n}\n/**\n * @param handlers -\n * @internal\n */\n\n\nfunction useTapGesture({\n  onTap,\n  onTapStart,\n  onTapCancel,\n  whileTap,\n  visualElement,\n  ...props\n}) {\n  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  const isPressing = useRef(false);\n  const cancelPointerEndListeners = useRef(null);\n  /**\n   * Only set listener to passive if there are no external listeners.\n   */\n\n  const eventOptions = {\n    passive: !(onTapStart || onTap || onTapCancel || props[\"onPointerDown\"])\n  };\n\n  function removePointerEndListener() {\n    cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n    cancelPointerEndListeners.current = null;\n  }\n\n  function checkPointerEnd() {\n    removePointerEndListener();\n    isPressing.current = false;\n    const latestProps = visualElement.getProps();\n\n    if (latestProps.whileTap && visualElement.animationState) {\n      visualElement.animationState.setActive(AnimationType.Tap, false);\n    }\n\n    return !isDragActive();\n  }\n\n  function onPointerUp(event, info) {\n    var _a, _b, _c, _d;\n\n    if (!checkPointerEnd()) return;\n    /**\n     * We only count this as a tap gesture if the event.target is the same\n     * as, or a child of, this component's element\n     */\n\n    !isNodeOrChild(visualElement.current, event.target) ? (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info) : (_d = (_c = visualElement.getProps()).onTap) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n  }\n\n  function onPointerCancel(event, info) {\n    var _a, _b;\n\n    if (!checkPointerEnd()) return;\n    (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n  }\n\n  function onPointerStart(event, info) {\n    var _a;\n\n    const latestProps = visualElement.getProps();\n    /**\n     * Ensure we trigger animations before firing event callback\n     */\n\n    if (latestProps.whileTap && visualElement.animationState) {\n      visualElement.animationState.setActive(AnimationType.Tap, true);\n    }\n\n    (_a = latestProps.onTapStart) === null || _a === void 0 ? void 0 : _a.call(latestProps, event, info);\n  }\n\n  const callbackDependencies = [Boolean(onTapStart), Boolean(onTap), Boolean(whileTap), visualElement];\n  const startPress = useCallback((event, info) => {\n    removePointerEndListener();\n    if (isPressing.current) return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n    onPointerStart(event, info);\n  }, callbackDependencies);\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? startPress : undefined, eventOptions);\n  const startAccessiblePress = useCallback(() => {\n    const stopKeydownListener = addDomEvent(visualElement.current, \"keydown\", event => {\n      if (event.key !== \"Enter\" || isPressing.current) return;\n      isPressing.current = true;\n      cancelPointerEndListeners.current = addDomEvent(visualElement.current, \"keyup\", () => {\n        if (event.key !== \"Enter\" || !checkPointerEnd()) return;\n        fireSyntheticPointerEvent(\"up\", visualElement.getProps().onTap);\n      }, eventOptions);\n      fireSyntheticPointerEvent(\"down\", onPointerStart);\n    });\n    const stopBlurListener = addDomEvent(visualElement.current, \"blur\", () => {\n      stopKeydownListener();\n      stopBlurListener();\n\n      if (isPressing.current) {\n        fireSyntheticPointerEvent(\"cancel\", onPointerCancel);\n      }\n    });\n  }, callbackDependencies);\n  useDomEvent(visualElement, \"focus\", hasPressListeners ? startAccessiblePress : undefined);\n  useUnmountEffect(removePointerEndListener);\n}\n\nexport { useTapGesture };","map":{"version":3,"sources":["/home/abdulsaabir/Documents/Projects/React/Tutorial Projects/Photo-Gallery-With-React-Firebase/node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs"],"names":["useRef","useCallback","isNodeOrChild","addPointerEvent","usePointerEvent","useUnmountEffect","AnimationType","isDragActive","pipe","addDomEvent","useDomEvent","extractEventInfo","fireSyntheticPointerEvent","name","handler","syntheticPointerEvent","PointerEvent","useTapGesture","onTap","onTapStart","onTapCancel","whileTap","visualElement","props","hasPressListeners","isPressing","cancelPointerEndListeners","eventOptions","passive","removePointerEndListener","current","checkPointerEnd","latestProps","getProps","animationState","setActive","Tap","onPointerUp","event","info","_a","_b","_c","_d","target","call","onPointerCancel","onPointerStart","callbackDependencies","Boolean","startPress","window","undefined","startAccessiblePress","stopKeydownListener","key","stopBlurListener"],"mappings":"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","sourcesContent":["import { useRef, useCallback } from 'react';\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\nimport { addPointerEvent, usePointerEvent } from '../events/use-pointer-event.mjs';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { isDragActive } from './drag/utils/lock.mjs';\nimport { pipe } from '../utils/pipe.mjs';\nimport { addDomEvent, useDomEvent } from '../events/use-dom-event.mjs';\nimport { extractEventInfo } from '../events/event-info.mjs';\n\nfunction fireSyntheticPointerEvent(name, handler) {\n    if (!handler)\n        return;\n    const syntheticPointerEvent = new PointerEvent(\"pointer\" + name);\n    handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));\n}\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement, ...props }) {\n    const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    const isPressing = useRef(false);\n    const cancelPointerEndListeners = useRef(null);\n    /**\n     * Only set listener to passive if there are no external listeners.\n     */\n    const eventOptions = {\n        passive: !(onTapStart ||\n            onTap ||\n            onTapCancel ||\n            props[\"onPointerDown\"]),\n    };\n    function removePointerEndListener() {\n        cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        removePointerEndListener();\n        isPressing.current = false;\n        const latestProps = visualElement.getProps();\n        if (latestProps.whileTap && visualElement.animationState) {\n            visualElement.animationState.setActive(AnimationType.Tap, false);\n        }\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        var _a, _b, _c, _d;\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */\n        !isNodeOrChild(visualElement.current, event.target)\n            ? (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info)\n            : (_d = (_c = visualElement.getProps()).onTap) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n    }\n    function onPointerCancel(event, info) {\n        var _a, _b;\n        if (!checkPointerEnd())\n            return;\n        (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n    }\n    function onPointerStart(event, info) {\n        var _a;\n        const latestProps = visualElement.getProps();\n        /**\n         * Ensure we trigger animations before firing event callback\n         */\n        if (latestProps.whileTap && visualElement.animationState) {\n            visualElement.animationState.setActive(AnimationType.Tap, true);\n        }\n        (_a = latestProps.onTapStart) === null || _a === void 0 ? void 0 : _a.call(latestProps, event, info);\n    }\n    const callbackDependencies = [\n        Boolean(onTapStart),\n        Boolean(onTap),\n        Boolean(whileTap),\n        visualElement,\n    ];\n    const startPress = useCallback((event, info) => {\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n        onPointerStart(event, info);\n    }, callbackDependencies);\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? startPress : undefined, eventOptions);\n    const startAccessiblePress = useCallback(() => {\n        const stopKeydownListener = addDomEvent(visualElement.current, \"keydown\", (event) => {\n            if (event.key !== \"Enter\" || isPressing.current)\n                return;\n            isPressing.current = true;\n            cancelPointerEndListeners.current = addDomEvent(visualElement.current, \"keyup\", () => {\n                if (event.key !== \"Enter\" || !checkPointerEnd())\n                    return;\n                fireSyntheticPointerEvent(\"up\", visualElement.getProps().onTap);\n            }, eventOptions);\n            fireSyntheticPointerEvent(\"down\", onPointerStart);\n        });\n        const stopBlurListener = addDomEvent(visualElement.current, \"blur\", () => {\n            stopKeydownListener();\n            stopBlurListener();\n            if (isPressing.current) {\n                fireSyntheticPointerEvent(\"cancel\", onPointerCancel);\n            }\n        });\n    }, callbackDependencies);\n    useDomEvent(visualElement, \"focus\", hasPressListeners ? startAccessiblePress : undefined);\n    useUnmountEffect(removePointerEndListener);\n}\n\nexport { useTapGesture };\n"]},"metadata":{},"sourceType":"module"}