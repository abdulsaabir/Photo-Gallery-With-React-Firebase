{"ast":null,"code":"import { setTarget } from './setters.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { transformProps } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { createMotionValueAnimation } from '../../animation/index.mjs';\nimport { sync } from '../../frameloop/index.mjs';\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n  visualElement.notify(\"AnimationStart\", definition);\n  let animation;\n\n  if (Array.isArray(definition)) {\n    const animations = definition.map(variant => animateVariant(visualElement, variant, options));\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    const resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n\n  return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\n}\n\nfunction animateVariant(visualElement, variant, options = {}) {\n  var _a;\n\n  const resolved = resolveVariant(visualElement, variant, options.custom);\n  let {\n    transition = visualElement.getDefaultTransition() || {}\n  } = resolved || {};\n\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n\n  const getAnimation = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n  const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? (forwardDelay = 0) => {\n    const {\n      delayChildren = 0,\n      staggerChildren,\n      staggerDirection\n    } = transition;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n\n  const {\n    when\n  } = transition;\n\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\n * @internal\n */\n\n\nfunction animateTarget(visualElement, definition, {\n  delay = 0,\n  transitionOverride,\n  type\n} = {}) {\n  var _a;\n\n  let {\n    transition = visualElement.getDefaultTransition(),\n    transitionEnd,\n    ...target\n  } = visualElement.makeTargetAnimatable(definition);\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride) transition = transitionOverride;\n  const animations = [];\n  const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n\n  for (const key in target) {\n    const value = visualElement.getValue(key);\n    const valueTarget = target[key];\n\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n\n    const valueTransition = {\n      delay,\n      elapsed: 0,\n      ...transition\n    };\n    /**\n     * If this is the first time a value is being animated, check\n     * to see if we're handling off from an existing animation.\n     */\n\n    if (window.HandoffAppearAnimations && !value.hasAnimated) {\n      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n\n      if (appearId) {\n        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, sync);\n      }\n    }\n\n    let animation = value.start(createMotionValueAnimation(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? {\n      type: false\n    } : valueTransition));\n\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(() => willChange.remove(key));\n    }\n\n    animations.push(animation);\n  }\n\n  return Promise.all(animations).then(() => {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\n\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n  const animations = [];\n  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, { ...options,\n      delay: delayChildren + generateStaggerDuration(i)\n    }).then(() => child.notify(\"AnimationComplete\", variant)));\n  });\n  return Promise.all(animations);\n}\n\nfunction stopAnimation(visualElement) {\n  visualElement.values.forEach(value => value.stop());\n}\n\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\n\n\nfunction shouldBlockAnimation({\n  protectedKeys,\n  needsAnimating\n}, key) {\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };","map":{"version":3,"sources":["/home/abdulsaabir/Documents/Projects/React/Tutorial Projects/Photo-Gallery-With-React-Firebase/node_modules/framer-motion/dist/es/render/utils/animation.mjs"],"names":["setTarget","resolveVariant","transformProps","isWillChangeMotionValue","optimizedAppearDataAttribute","createMotionValueAnimation","sync","animateVisualElement","visualElement","definition","options","notify","animation","Array","isArray","animations","map","variant","animateVariant","Promise","all","resolvedDefinition","custom","animateTarget","then","_a","resolved","transition","getDefaultTransition","transitionOverride","getAnimation","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","delay","type","transitionEnd","target","makeTargetAnimatable","willChange","getValue","animationTypeState","animationState","getState","key","value","valueTarget","undefined","shouldBlockAnimation","valueTransition","elapsed","window","HandoffAppearAnimations","hasAnimated","appearId","getProps","start","shouldReduceMotion","has","add","remove","push","maxStaggerDuration","generateStaggerDuration","i","from","sort","sortByTreeOrder","forEach","child","stopAnimation","values","stop","a","b","sortNodePosition","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty"],"mappings":"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","sourcesContent":["import { setTarget } from './setters.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { transformProps } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { createMotionValueAnimation } from '../../animation/index.mjs';\nimport { sync } from '../../frameloop/index.mjs';\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\n}\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.custom);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => animateTarget(visualElement, resolved, options)\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, { delay = 0, transitionOverride, type } = {}) {\n    var _a;\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);\n    const willChange = visualElement.getValue(\"willChange\");\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n    for (const key in target) {\n        const value = visualElement.getValue(key);\n        const valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = { delay, elapsed: 0, ...transition };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        if (window.HandoffAppearAnimations && !value.hasAnimated) {\n            const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n            if (appearId) {\n                valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, sync);\n            }\n        }\n        let animation = value.start(createMotionValueAnimation(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key)\n            ? { type: false }\n            : valueTransition));\n        if (isWillChangeMotionValue(willChange)) {\n            willChange.add(key);\n            animation = animation.then(() => willChange.remove(key));\n        }\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(() => {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };\n"]},"metadata":{},"sourceType":"module"}