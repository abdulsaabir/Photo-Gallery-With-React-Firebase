{"ast":null,"code":"import { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nconst types = {\n  decay,\n  keyframes: keyframes,\n  tween: keyframes,\n  spring\n};\n\nfunction loopElapsed(elapsed, duration, delay = 0) {\n  return elapsed - duration - delay;\n}\n\nfunction reverseElapsed(elapsed, duration = 0, delay = 0, isForwardPlayback = true) {\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\n\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\n\nconst framesync = update => {\n  const passTimestamp = ({\n    delta\n  }) => update(delta);\n\n  return {\n    start: () => sync.update(passTimestamp, true),\n    stop: () => cancelSync.update(passTimestamp)\n  };\n};\n\nfunction animate({\n  duration,\n  driver = framesync,\n  elapsed = 0,\n  repeat: repeatMax = 0,\n  repeatType = \"loop\",\n  repeatDelay = 0,\n  keyframes: keyframes$1,\n  autoplay = true,\n  onPlay,\n  onStop,\n  onComplete,\n  onRepeat,\n  onUpdate,\n  type = \"keyframes\",\n  ...options\n}) {\n  var _a, _b;\n\n  const initialElapsed = elapsed;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = duration;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\n  const origin = keyframes$1[0];\n  const target = keyframes$1[keyframes$1.length - 1];\n  let state = {\n    done: false,\n    value: origin\n  };\n\n  if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {\n    interpolateFromNumber = interpolate([0, 100], [origin, target], {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n\n  const animation = animator({ ...options,\n    duration,\n    keyframes: keyframes$1\n  });\n\n  function repeat() {\n    repeatCount++;\n\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\") animation.flipTarget();\n    }\n\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n\n  function complete() {\n    driverControls && driverControls.stop();\n    onComplete && onComplete();\n  }\n\n  function update(delta) {\n    if (!isForwardPlayback) delta = -delta;\n    elapsed += delta;\n\n    if (!isComplete) {\n      state = animation.next(Math.max(0, elapsed));\n      if (interpolateFromNumber) state.value = interpolateFromNumber(state.value);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n\n    onUpdate && onUpdate(state.value);\n\n    if (isComplete) {\n      if (repeatCount === 0) {\n        computedDuration = computedDuration !== undefined ? computedDuration : elapsed;\n      }\n\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n\n  function play() {\n    onPlay && onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop && onStop();\n      driverControls && driverControls.stop();\n    },\n\n    /**\n     * Set the current time of the animation. This is purposefully\n     * mirroring the WAAPI animation API to make them interchanagable.\n     * Going forward this file should be ported more towards\n     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts\n     * Which behaviourally adheres to WAAPI as far as possible.\n     *\n     * WARNING: This is not safe to use for most animations. We currently\n     * only use it for handoff from WAAPI within Framer.\n     *\n     * This animation function consumes time every frame rather than being sampled for time.\n     * So the sample() method performs some headless frames to ensure\n     * repeats are handled correctly. Ideally in the future we will replace\n     * that method with this, once repeat calculations are pure.\n     */\n    set currentTime(t) {\n      elapsed = initialElapsed;\n      update(t);\n    },\n\n    /**\n     * animate() can't yet be sampled for time, instead it\n     * consumes time. So to sample it we have to run a low\n     * temporal-resolution version.\n     */\n    sample: t => {\n      elapsed = initialElapsed;\n      const sampleResolution = duration && typeof duration === \"number\" ? Math.max(duration * 0.5, 50) : 50;\n      let sampleElapsed = 0;\n      update(0);\n\n      while (sampleElapsed <= t) {\n        const remaining = t - sampleElapsed;\n        update(Math.min(remaining, sampleResolution));\n        sampleElapsed += sampleResolution;\n      }\n\n      return state;\n    }\n  };\n}\n\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };","map":{"version":3,"sources":["/home/abdulsaabir/Documents/Projects/React/Tutorial Projects/Photo-Gallery-With-React-Firebase/node_modules/framer-motion/dist/es/animation/legacy-popmotion/index.mjs"],"names":["keyframes","spring","decay","sync","cancelSync","interpolate","types","tween","loopElapsed","elapsed","duration","delay","reverseElapsed","isForwardPlayback","hasRepeatDelayElapsed","framesync","update","passTimestamp","delta","start","stop","animate","driver","repeat","repeatMax","repeatType","repeatDelay","keyframes$1","autoplay","onPlay","onStop","onComplete","onRepeat","onUpdate","type","options","_a","_b","initialElapsed","driverControls","repeatCount","computedDuration","isComplete","interpolateFromNumber","animator","length","origin","target","state","done","value","needsInterpolation","call","clamp","animation","flipTarget","complete","next","Math","max","undefined","play","currentTime","t","sample","sampleResolution","sampleElapsed","remaining","min"],"mappings":"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","sourcesContent":["import { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\n\nconst types = {\n    decay,\n    keyframes: keyframes,\n    tween: keyframes,\n    spring,\n};\nfunction loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration = 0, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback\n        ? loopElapsed(duration + -elapsed, duration, delay)\n        : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => sync.update(passTimestamp, true),\n        stop: () => cancelSync.update(passTimestamp),\n    };\n};\nfunction animate({ duration, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, keyframes: keyframes$1, autoplay = true, onPlay, onStop, onComplete, onRepeat, onUpdate, type = \"keyframes\", ...options }) {\n    var _a, _b;\n    const initialElapsed = elapsed;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = duration;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\n    const origin = keyframes$1[0];\n    const target = keyframes$1[keyframes$1.length - 1];\n    let state = { done: false, value: origin };\n    if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {\n        interpolateFromNumber = interpolate([0, 100], [origin, target], {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const animation = animator({\n        ...options,\n        duration,\n        keyframes: keyframes$1,\n    });\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls && driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            state = animation.next(Math.max(0, elapsed));\n            if (interpolateFromNumber)\n                state.value = interpolateFromNumber(state.value);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate && onUpdate(state.value);\n        if (isComplete) {\n            if (repeatCount === 0) {\n                computedDuration =\n                    computedDuration !== undefined ? computedDuration : elapsed;\n            }\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay && onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop && onStop();\n            driverControls && driverControls.stop();\n        },\n        /**\n         * Set the current time of the animation. This is purposefully\n         * mirroring the WAAPI animation API to make them interchanagable.\n         * Going forward this file should be ported more towards\n         * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts\n         * Which behaviourally adheres to WAAPI as far as possible.\n         *\n         * WARNING: This is not safe to use for most animations. We currently\n         * only use it for handoff from WAAPI within Framer.\n         *\n         * This animation function consumes time every frame rather than being sampled for time.\n         * So the sample() method performs some headless frames to ensure\n         * repeats are handled correctly. Ideally in the future we will replace\n         * that method with this, once repeat calculations are pure.\n         */\n        set currentTime(t) {\n            elapsed = initialElapsed;\n            update(t);\n        },\n        /**\n         * animate() can't yet be sampled for time, instead it\n         * consumes time. So to sample it we have to run a low\n         * temporal-resolution version.\n         */\n        sample: (t) => {\n            elapsed = initialElapsed;\n            const sampleResolution = duration && typeof duration === \"number\"\n                ? Math.max(duration * 0.5, 50)\n                : 50;\n            let sampleElapsed = 0;\n            update(0);\n            while (sampleElapsed <= t) {\n                const remaining = t - sampleElapsed;\n                update(Math.min(remaining, sampleResolution));\n                sampleElapsed += sampleResolution;\n            }\n            return state;\n        },\n    };\n}\n\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };\n"]},"metadata":{},"sourceType":"module"}