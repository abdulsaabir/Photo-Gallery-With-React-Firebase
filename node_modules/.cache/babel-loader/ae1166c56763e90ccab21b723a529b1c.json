{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar generators = require('@motionone/generators');\n\nvar utils = require('@motionone/utils');\n\nvar getUnit = require('../animate/utils/get-unit.cjs.js');\n\nvar transforms = require('../animate/utils/transforms.cjs.js');\n\nvar getStyleName = require('../animate/utils/get-style-name.cjs.js');\n\nfunction canGenerate(value) {\n  return utils.isNumber(value) && !isNaN(value);\n}\n\nfunction getAsNumber(value) {\n  return utils.isString(value) ? parseFloat(value) : value;\n}\n\nfunction createGeneratorEasing(createGenerator) {\n  const keyframesCache = new WeakMap();\n  return (options = {}) => {\n    const generatorCache = new Map();\n\n    const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {\n      const key = `${from}-${to}-${velocity}-${isScale}`;\n\n      if (!generatorCache.has(key)) {\n        generatorCache.set(key, createGenerator(Object.assign({\n          from,\n          to,\n          velocity,\n          restSpeed: isScale ? 0.05 : 2,\n          restDistance: isScale ? 0.01 : 0.5\n        }, options)));\n      }\n\n      return generatorCache.get(key);\n    };\n\n    const getKeyframes = (generator, toUnit) => {\n      if (!keyframesCache.has(generator)) {\n        keyframesCache.set(generator, generators.pregenerateKeyframes(generator, toUnit));\n      }\n\n      return keyframesCache.get(generator);\n    };\n\n    return {\n      createAnimation: (keyframes, shouldGenerate = true, getOrigin, name, motionValue) => {\n        let settings;\n        let origin;\n        let target;\n        let velocity = 0;\n        let toUnit = utils.noopReturn;\n        const numKeyframes = keyframes.length;\n        /**\n         * If we should generate an animation for this value, run some preperation\n         * like resolving target/origin, finding a unit (if any) and determine if\n         * it is actually possible to generate.\n         */\n\n        if (shouldGenerate) {\n          toUnit = getUnit.getUnitConverter(keyframes, name ? transforms.transformDefinitions.get(getStyleName.getStyleName(name)) : undefined);\n          const targetDefinition = keyframes[numKeyframes - 1];\n          target = getAsNumber(targetDefinition);\n\n          if (numKeyframes > 1 && keyframes[0] !== null) {\n            /**\n             * If we have multiple keyframes, take the initial keyframe as the origin.\n             */\n            origin = getAsNumber(keyframes[0]);\n          } else {\n            const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\n            /**\n             * If we have an existing generator for this value we can use it to resolve\n             * the animation's current value and velocity.\n             */\n\n            if (prevGenerator) {\n              /**\n               * If we have a generator for this value we can use it to resolve\n               * the animations's current value and velocity.\n               */\n              const {\n                animation,\n                generatorStartTime\n              } = motionValue;\n              const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\n              const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\n              const prevGeneratorCurrent = prevGenerator(currentTime).current;\n              origin = prevGeneratorCurrent;\n              velocity = generators.calcGeneratorVelocity(t => prevGenerator(t).current, currentTime, prevGeneratorCurrent);\n            } else if (getOrigin) {\n              /**\n               * As a last resort, read the origin from the DOM.\n               */\n              origin = getAsNumber(getOrigin());\n            }\n          }\n        }\n        /**\n         * If we've determined it is possible to generate an animation, do so.\n         */\n\n\n        if (canGenerate(origin) && canGenerate(target)) {\n          const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\n          settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), {\n            easing: \"linear\"\n          }); // TODO Add test for this\n\n          if (motionValue) {\n            motionValue.generator = generator;\n            motionValue.generatorStartTime = performance.now();\n          }\n        }\n        /**\n         * If by now we haven't generated a set of keyframes, create a generic generator\n         * based on the provided props that animates from 0-100 to fetch a rough\n         * \"overshootDuration\" - the moment when the generator first hits the animation target.\n         * Then return animation settings that will run a normal animation for that duration.\n         */\n\n\n        if (!settings) {\n          const keyframesMetadata = getKeyframes(getGenerator(0, 100));\n          settings = {\n            easing: \"ease\",\n            duration: keyframesMetadata.overshootDuration\n          };\n        }\n\n        return settings;\n      }\n    };\n  };\n}\n\nexports.createGeneratorEasing = createGeneratorEasing;","map":{"version":3,"sources":["/home/abdulsaabir/Documents/Projects/React/Tutorial Projects/Photo-Gallery-With-React-Firebase/node_modules/@motionone/dom/dist/easing/create-generator-easing.cjs.js"],"names":["Object","defineProperty","exports","value","generators","require","utils","getUnit","transforms","getStyleName","canGenerate","isNumber","isNaN","getAsNumber","isString","parseFloat","createGeneratorEasing","createGenerator","keyframesCache","WeakMap","options","generatorCache","Map","getGenerator","from","to","velocity","isScale","key","has","set","assign","restSpeed","restDistance","get","getKeyframes","generator","toUnit","pregenerateKeyframes","createAnimation","keyframes","shouldGenerate","getOrigin","name","motionValue","settings","origin","target","noopReturn","numKeyframes","length","getUnitConverter","transformDefinitions","undefined","targetDefinition","prevGenerator","animation","generatorStartTime","startTime","currentTime","performance","now","prevGeneratorCurrent","current","calcGeneratorVelocity","t","includes","easing","keyframesMetadata","duration","overshootDuration"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,UAAU,GAAGC,OAAO,CAAC,uBAAD,CAAxB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,kBAAD,CAAnB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,kCAAD,CAArB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,oCAAD,CAAxB;;AACA,IAAII,YAAY,GAAGJ,OAAO,CAAC,wCAAD,CAA1B;;AAEA,SAASK,WAAT,CAAqBP,KAArB,EAA4B;AACxB,SAAOG,KAAK,CAACK,QAAN,CAAeR,KAAf,KAAyB,CAACS,KAAK,CAACT,KAAD,CAAtC;AACH;;AACD,SAASU,WAAT,CAAqBV,KAArB,EAA4B;AACxB,SAAOG,KAAK,CAACQ,QAAN,CAAeX,KAAf,IAAwBY,UAAU,CAACZ,KAAD,CAAlC,GAA4CA,KAAnD;AACH;;AACD,SAASa,qBAAT,CAA+BC,eAA/B,EAAgD;AAC5C,QAAMC,cAAc,GAAG,IAAIC,OAAJ,EAAvB;AACA,SAAO,CAACC,OAAO,GAAG,EAAX,KAAkB;AACrB,UAAMC,cAAc,GAAG,IAAIC,GAAJ,EAAvB;;AACA,UAAMC,YAAY,GAAG,CAACC,IAAI,GAAG,CAAR,EAAWC,EAAE,GAAG,GAAhB,EAAqBC,QAAQ,GAAG,CAAhC,EAAmCC,OAAO,GAAG,KAA7C,KAAuD;AACxE,YAAMC,GAAG,GAAI,GAAEJ,IAAK,IAAGC,EAAG,IAAGC,QAAS,IAAGC,OAAQ,EAAjD;;AACA,UAAI,CAACN,cAAc,CAACQ,GAAf,CAAmBD,GAAnB,CAAL,EAA8B;AAC1BP,QAAAA,cAAc,CAACS,GAAf,CAAmBF,GAAnB,EAAwBX,eAAe,CAACjB,MAAM,CAAC+B,MAAP,CAAc;AAAEP,UAAAA,IAAF;AAClDC,UAAAA,EADkD;AAElDC,UAAAA,QAFkD;AAExCM,UAAAA,SAAS,EAAEL,OAAO,GAAG,IAAH,GAAU,CAFY;AAETM,UAAAA,YAAY,EAAEN,OAAO,GAAG,IAAH,GAAU;AAFtB,SAAd,EAE2CP,OAF3C,CAAD,CAAvC;AAGH;;AACD,aAAOC,cAAc,CAACa,GAAf,CAAmBN,GAAnB,CAAP;AACH,KARD;;AASA,UAAMO,YAAY,GAAG,CAACC,SAAD,EAAYC,MAAZ,KAAuB;AACxC,UAAI,CAACnB,cAAc,CAACW,GAAf,CAAmBO,SAAnB,CAAL,EAAoC;AAChClB,QAAAA,cAAc,CAACY,GAAf,CAAmBM,SAAnB,EAA8BhC,UAAU,CAACkC,oBAAX,CAAgCF,SAAhC,EAA2CC,MAA3C,CAA9B;AACH;;AACD,aAAOnB,cAAc,CAACgB,GAAf,CAAmBE,SAAnB,CAAP;AACH,KALD;;AAMA,WAAO;AACHG,MAAAA,eAAe,EAAE,CAACC,SAAD,EAAYC,cAAc,GAAG,IAA7B,EAAmCC,SAAnC,EAA8CC,IAA9C,EAAoDC,WAApD,KAAoE;AACjF,YAAIC,QAAJ;AACA,YAAIC,MAAJ;AACA,YAAIC,MAAJ;AACA,YAAIrB,QAAQ,GAAG,CAAf;AACA,YAAIW,MAAM,GAAG/B,KAAK,CAAC0C,UAAnB;AACA,cAAMC,YAAY,GAAGT,SAAS,CAACU,MAA/B;AACA;;;;;;AAKA,YAAIT,cAAJ,EAAoB;AAChBJ,UAAAA,MAAM,GAAG9B,OAAO,CAAC4C,gBAAR,CAAyBX,SAAzB,EAAoCG,IAAI,GAAGnC,UAAU,CAAC4C,oBAAX,CAAgClB,GAAhC,CAAoCzB,YAAY,CAACA,YAAb,CAA0BkC,IAA1B,CAApC,CAAH,GAA0EU,SAAlH,CAAT;AACA,gBAAMC,gBAAgB,GAAGd,SAAS,CAACS,YAAY,GAAG,CAAhB,CAAlC;AACAF,UAAAA,MAAM,GAAGlC,WAAW,CAACyC,gBAAD,CAApB;;AACA,cAAIL,YAAY,GAAG,CAAf,IAAoBT,SAAS,CAAC,CAAD,CAAT,KAAiB,IAAzC,EAA+C;AAC3C;;;AAGAM,YAAAA,MAAM,GAAGjC,WAAW,CAAC2B,SAAS,CAAC,CAAD,CAAV,CAApB;AACH,WALD,MAMK;AACD,kBAAMe,aAAa,GAAGX,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,WAAW,CAACR,SAA5F;AACA;;;;;AAIA,gBAAImB,aAAJ,EAAmB;AACf;;;;AAIA,oBAAM;AAAEC,gBAAAA,SAAF;AAAaC,gBAAAA;AAAb,kBAAoCb,WAA1C;AACA,oBAAMc,SAAS,GAAG,CAACF,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACE,SAAjE,KAA+ED,kBAA/E,IAAqG,CAAvH;AACA,oBAAME,WAAW,GAAG,CAACH,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACG,WAAjE,KAAiFC,WAAW,CAACC,GAAZ,KAAoBH,SAAzH;AACA,oBAAMI,oBAAoB,GAAGP,aAAa,CAACI,WAAD,CAAb,CAA2BI,OAAxD;AACAjB,cAAAA,MAAM,GAAGgB,oBAAT;AACApC,cAAAA,QAAQ,GAAGtB,UAAU,CAAC4D,qBAAX,CAAkCC,CAAD,IAAOV,aAAa,CAACU,CAAD,CAAb,CAAiBF,OAAzD,EAAkEJ,WAAlE,EAA+EG,oBAA/E,CAAX;AACH,aAXD,MAYK,IAAIpB,SAAJ,EAAe;AAChB;;;AAGAI,cAAAA,MAAM,GAAGjC,WAAW,CAAC6B,SAAS,EAAV,CAApB;AACH;AACJ;AACJ;AACD;;;;;AAGA,YAAIhC,WAAW,CAACoC,MAAD,CAAX,IAAuBpC,WAAW,CAACqC,MAAD,CAAtC,EAAgD;AAC5C,gBAAMX,SAAS,GAAGb,YAAY,CAACuB,MAAD,EAASC,MAAT,EAAiBrB,QAAjB,EAA2BiB,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACuB,QAAL,CAAc,OAAd,CAAvE,CAA9B;AACArB,UAAAA,QAAQ,GAAG7C,MAAM,CAAC+B,MAAP,CAAc/B,MAAM,CAAC+B,MAAP,CAAc,EAAd,EAAkBI,YAAY,CAACC,SAAD,EAAYC,MAAZ,CAA9B,CAAd,EAAkE;AAAE8B,YAAAA,MAAM,EAAE;AAAV,WAAlE,CAAX,CAF4C,CAG5C;;AACA,cAAIvB,WAAJ,EAAiB;AACbA,YAAAA,WAAW,CAACR,SAAZ,GAAwBA,SAAxB;AACAQ,YAAAA,WAAW,CAACa,kBAAZ,GAAiCG,WAAW,CAACC,GAAZ,EAAjC;AACH;AACJ;AACD;;;;;;;;AAMA,YAAI,CAAChB,QAAL,EAAe;AACX,gBAAMuB,iBAAiB,GAAGjC,YAAY,CAACZ,YAAY,CAAC,CAAD,EAAI,GAAJ,CAAb,CAAtC;AACAsB,UAAAA,QAAQ,GAAG;AACPsB,YAAAA,MAAM,EAAE,MADD;AAEPE,YAAAA,QAAQ,EAAED,iBAAiB,CAACE;AAFrB,WAAX;AAIH;;AACD,eAAOzB,QAAP;AACH;AA3EE,KAAP;AA6EH,GA9FD;AA+FH;;AAED3C,OAAO,CAACc,qBAAR,GAAgCA,qBAAhC","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar generators = require('@motionone/generators');\nvar utils = require('@motionone/utils');\nvar getUnit = require('../animate/utils/get-unit.cjs.js');\nvar transforms = require('../animate/utils/transforms.cjs.js');\nvar getStyleName = require('../animate/utils/get-style-name.cjs.js');\n\nfunction canGenerate(value) {\n    return utils.isNumber(value) && !isNaN(value);\n}\nfunction getAsNumber(value) {\n    return utils.isString(value) ? parseFloat(value) : value;\n}\nfunction createGeneratorEasing(createGenerator) {\n    const keyframesCache = new WeakMap();\n    return (options = {}) => {\n        const generatorCache = new Map();\n        const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {\n            const key = `${from}-${to}-${velocity}-${isScale}`;\n            if (!generatorCache.has(key)) {\n                generatorCache.set(key, createGenerator(Object.assign({ from,\n                    to,\n                    velocity, restSpeed: isScale ? 0.05 : 2, restDistance: isScale ? 0.01 : 0.5 }, options)));\n            }\n            return generatorCache.get(key);\n        };\n        const getKeyframes = (generator, toUnit) => {\n            if (!keyframesCache.has(generator)) {\n                keyframesCache.set(generator, generators.pregenerateKeyframes(generator, toUnit));\n            }\n            return keyframesCache.get(generator);\n        };\n        return {\n            createAnimation: (keyframes, shouldGenerate = true, getOrigin, name, motionValue) => {\n                let settings;\n                let origin;\n                let target;\n                let velocity = 0;\n                let toUnit = utils.noopReturn;\n                const numKeyframes = keyframes.length;\n                /**\n                 * If we should generate an animation for this value, run some preperation\n                 * like resolving target/origin, finding a unit (if any) and determine if\n                 * it is actually possible to generate.\n                 */\n                if (shouldGenerate) {\n                    toUnit = getUnit.getUnitConverter(keyframes, name ? transforms.transformDefinitions.get(getStyleName.getStyleName(name)) : undefined);\n                    const targetDefinition = keyframes[numKeyframes - 1];\n                    target = getAsNumber(targetDefinition);\n                    if (numKeyframes > 1 && keyframes[0] !== null) {\n                        /**\n                         * If we have multiple keyframes, take the initial keyframe as the origin.\n                         */\n                        origin = getAsNumber(keyframes[0]);\n                    }\n                    else {\n                        const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\n                        /**\n                         * If we have an existing generator for this value we can use it to resolve\n                         * the animation's current value and velocity.\n                         */\n                        if (prevGenerator) {\n                            /**\n                             * If we have a generator for this value we can use it to resolve\n                             * the animations's current value and velocity.\n                             */\n                            const { animation, generatorStartTime } = motionValue;\n                            const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\n                            const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\n                            const prevGeneratorCurrent = prevGenerator(currentTime).current;\n                            origin = prevGeneratorCurrent;\n                            velocity = generators.calcGeneratorVelocity((t) => prevGenerator(t).current, currentTime, prevGeneratorCurrent);\n                        }\n                        else if (getOrigin) {\n                            /**\n                             * As a last resort, read the origin from the DOM.\n                             */\n                            origin = getAsNumber(getOrigin());\n                        }\n                    }\n                }\n                /**\n                 * If we've determined it is possible to generate an animation, do so.\n                 */\n                if (canGenerate(origin) && canGenerate(target)) {\n                    const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\n                    settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), { easing: \"linear\" });\n                    // TODO Add test for this\n                    if (motionValue) {\n                        motionValue.generator = generator;\n                        motionValue.generatorStartTime = performance.now();\n                    }\n                }\n                /**\n                 * If by now we haven't generated a set of keyframes, create a generic generator\n                 * based on the provided props that animates from 0-100 to fetch a rough\n                 * \"overshootDuration\" - the moment when the generator first hits the animation target.\n                 * Then return animation settings that will run a normal animation for that duration.\n                 */\n                if (!settings) {\n                    const keyframesMetadata = getKeyframes(getGenerator(0, 100));\n                    settings = {\n                        easing: \"ease\",\n                        duration: keyframesMetadata.overshootDuration,\n                    };\n                }\n                return settings;\n            },\n        };\n    };\n}\n\nexports.createGeneratorEasing = createGeneratorEasing;\n"]},"metadata":{},"sourceType":"script"}